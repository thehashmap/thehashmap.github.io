"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parseley";
exports.ids = ["vendor-chunks/parseley"];
exports.modules = {

/***/ "(action-browser)/./node_modules/parseley/lib/parseley.cjs":
/*!************************************************!*\
  !*** ./node_modules/parseley/lib/parseley.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar leac = __webpack_require__(/*! leac */ \"(action-browser)/./node_modules/leac/lib/leac.cjs\");\nvar p = __webpack_require__(/*! peberminta */ \"(action-browser)/./node_modules/peberminta/lib/core.cjs\");\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\nvar p__namespace = /*#__PURE__*/ _interopNamespace(p);\nvar ast = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst lex = leac.createLexer([\n    {\n        name: \"ws\",\n        regex: /[ \\t\\r\\n\\f]+/\n    },\n    {\n        name: \"idn\",\n        regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/\n    },\n    {\n        name: \"#id\",\n        regex: /#[a-zA-Z0-9_-]+/\n    },\n    {\n        name: \"str1\",\n        regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/\n    },\n    {\n        name: \"str2\",\n        regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/\n    },\n    {\n        name: \"*\"\n    },\n    {\n        name: \".\"\n    },\n    {\n        name: \",\"\n    },\n    {\n        name: \"[\"\n    },\n    {\n        name: \"]\"\n    },\n    {\n        name: \"=\"\n    },\n    {\n        name: \">\"\n    },\n    {\n        name: \"|\"\n    },\n    {\n        name: \"+\"\n    },\n    {\n        name: \"~\"\n    },\n    {\n        name: \"^\"\n    },\n    {\n        name: \"$\"\n    }\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [\n        a0 + b0,\n        a1 + b1,\n        a2 + b2\n    ];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [\n        0,\n        0,\n        0\n    ]);\n}\nfunction literal(name) {\n    return p__namespace.token((t)=>t.name === name ? true : undefined);\n}\nconst whitespace_ = p__namespace.token((t)=>t.name === \"ws\" ? null : undefined);\nconst optionalWhitespace_ = p__namespace.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = p__namespace.token((t)=>t.name === \"idn\" ? t.text : undefined);\nconst hashId_ = p__namespace.token((t)=>t.name === \"#id\" ? t.text.slice(1) : undefined);\nconst string_ = p__namespace.token((t)=>t.name.startsWith(\"str\") ? t.text.slice(1, -1) : undefined);\nconst namespace_ = p__namespace.left(p__namespace.option(identifier_, \"\"), literal(\"|\"));\nconst qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name)=>({\n        name: name,\n        namespace: ns\n    })), p__namespace.map(identifier_, (name)=>({\n        name: name,\n        namespace: null\n    })));\nconst uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal(\"*\"), (ns)=>({\n        type: \"universal\",\n        namespace: ns,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })), p__namespace.map(literal(\"*\"), ()=>({\n        type: \"universal\",\n        namespace: null,\n        specificity: [\n            0,\n            0,\n            0\n        ]\n    })));\nconst tagSelector_ = p__namespace.map(qualifiedName_, ({ name, namespace })=>({\n        type: \"tag\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            0,\n            1\n        ]\n    }));\nconst classSelector_ = p__namespace.ab(literal(\".\"), identifier_, (fullstop, name)=>({\n        type: \"class\",\n        name: name,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst idSelector_ = p__namespace.map(hashId_, (name)=>({\n        type: \"id\",\n        name: name,\n        specificity: [\n            1,\n            0,\n            0\n        ]\n    }));\nconst attrModifier_ = p__namespace.token((t)=>{\n    if (t.name === \"idn\") {\n        if (t.text === \"i\" || t.text === \"I\") {\n            return \"i\";\n        }\n        if (t.text === \"s\" || t.text === \"S\") {\n            return \"s\";\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod)=>({\n        value: v,\n        modifier: mod\n    })));\nconst attrMatcher_ = p__namespace.choice(p__namespace.map(literal(\"=\"), ()=>\"=\"), p__namespace.ab(literal(\"~\"), literal(\"=\"), ()=>\"~=\"), p__namespace.ab(literal(\"|\"), literal(\"=\"), ()=>\"|=\"), p__namespace.ab(literal(\"^\"), literal(\"=\"), ()=>\"^=\"), p__namespace.ab(literal(\"$\"), literal(\"=\"), ()=>\"$=\"), p__namespace.ab(literal(\"*\"), literal(\"=\"), ()=>\"*=\"));\nconst attrPresenceSelector_ = p__namespace.abc(literal(\"[\"), optionallySpaced(qualifiedName_), literal(\"]\"), (lbr, { name, namespace })=>({\n        type: \"attrPresence\",\n        name: name,\n        namespace: namespace,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    }));\nconst attrValueSelector_ = p__namespace.middle(literal(\"[\"), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier })=>({\n        type: \"attrValue\",\n        name: name,\n        namespace: namespace,\n        matcher: matcher,\n        value: value,\n        modifier: modifier,\n        specificity: [\n            0,\n            1,\n            0\n        ]\n    })), literal(\"]\"));\nconst attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss)=>{\n    return {\n        type: \"compound\",\n        list: ss,\n        specificity: sumAllSpec(ss.map((s)=>s.specificity))\n    };\n});\nconst combinator_ = p__namespace.choice(p__namespace.map(literal(\">\"), ()=>\">\"), p__namespace.map(literal(\"+\"), ()=>\"+\"), p__namespace.map(literal(\"~\"), ()=>\"~\"), p__namespace.ab(literal(\"|\"), literal(\"|\"), ()=>\"||\"));\nconst combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, ()=>\" \"));\nconst complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c)=>(left, right)=>({\n            type: \"compound\",\n            list: [\n                ...right.list,\n                {\n                    type: \"combinator\",\n                    combinator: c,\n                    left: left,\n                    specificity: left.specificity\n                }\n            ],\n            specificity: sumSpec(left.specificity, right.specificity)\n        })), compoundSelector_);\nconst listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s)=>({\n        type: \"list\",\n        list: [\n            s\n        ]\n    })), p__namespace.map(optionallySpaced(literal(\",\")), ()=>(acc, next)=>({\n            type: \"list\",\n            list: [\n                ...acc.list,\n                next\n            ]\n        })), complexSelector_);\nfunction parse_(parser, str) {\n    const lexerResult = lex(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` + prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({\n        tokens: lexerResult.tokens,\n        options: undefined\n    }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` + prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r)=>t ? \"␉\" : r ? \"␍\" : \"␊\")}\\n${\"\".padEnd(offset)}${\"^\".repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"universal\":\n            return _serNs(selector.namespace) + \"*\";\n        case \"tag\":\n            return _serNs(selector.namespace) + selector.name;\n        case \"class\":\n            return \".\" + selector.name;\n        case \"id\":\n            return \"#\" + selector.name;\n        case \"attrPresence\":\n            return `[${_serNs(selector.namespace)}${selector.name}]`;\n        case \"attrValue\":\n            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${selector.modifier ? selector.modifier : \"\"}]`;\n        case \"combinator\":\n            return serialize(selector.left) + selector.combinator;\n        case \"compound\":\n            return selector.list.reduce((acc, node)=>{\n                if (node.type === \"combinator\") {\n                    return serialize(node) + acc;\n                } else {\n                    return acc + serialize(node);\n                }\n            }, \"\");\n        case \"list\":\n            return selector.list.map(serialize).join(\",\");\n    }\n}\nfunction _serNs(ns) {\n    return ns || ns === \"\" ? ns + \"|\" : \"\";\n}\nfunction _serStr(str) {\n    if (str.indexOf('\"') === -1) {\n        return `\"${str}\"`;\n    } else if (str.indexOf(\"'\") === -1) {\n        return `'${str}'`;\n    } else {\n        return `\"${str.replace('\"', '\\\\\"')}\"`;\n    }\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error(\"This is not an AST node.\");\n    }\n    switch(selector.type){\n        case \"compound\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>_compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n                break;\n            }\n        case \"combinator\":\n            {\n                normalize(selector.left);\n                break;\n            }\n        case \"list\":\n            {\n                selector.list.forEach(normalize);\n                selector.list.sort((a, b)=>serialize(a) < serialize(b) ? -1 : 1);\n                break;\n            }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch(selector.type){\n        case \"universal\":\n            return [\n                1\n            ];\n        case \"tag\":\n            return [\n                1\n            ];\n        case \"id\":\n            return [\n                2\n            ];\n        case \"class\":\n            return [\n                3,\n                selector.name\n            ];\n        case \"attrPresence\":\n            return [\n                4,\n                serialize(selector)\n            ];\n        case \"attrValue\":\n            return [\n                5,\n                serialize(selector)\n            ];\n        case \"combinator\":\n            return [\n                15,\n                serialize(selector)\n            ];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error(\"Arguments must be arrays.\");\n    }\n    const shorter = a.length < b.length ? a.length : b.length;\n    for(let i = 0; i < shorter; i++){\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return a[i] < b[i] ? -1 : 1;\n    }\n    return a.length - b.length;\n}\nexports.Ast = ast;\nexports.compareSelectors = compareSelectors;\nexports.compareSpecificity = compareSpecificity;\nexports.normalize = normalize;\nexports.parse = parse;\nexports.parse1 = parse1;\nexports.serialize = serialize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXJzZWxleS9saWIvcGFyc2VsZXkuY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLElBQUlELG1CQUFPQSxDQUFDO0FBRWhCLFNBQVNFLGtCQUFrQkMsQ0FBQztJQUN4QixJQUFJQSxLQUFLQSxFQUFFQyxVQUFVLEVBQUUsT0FBT0Q7SUFDOUIsSUFBSUUsSUFBSVYsT0FBT1csTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDSFIsT0FBT1ksSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUM5QixJQUFJQSxNQUFNLFdBQVc7Z0JBQ2pCLElBQUlDLElBQUlmLE9BQU9nQix3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDZCxPQUFPQyxjQUFjLENBQUNTLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDcENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNwQztZQUNKO1FBQ0o7SUFDSjtJQUNBSixDQUFDLENBQUMsVUFBVSxHQUFHRjtJQUNmLE9BQU9SLE9BQU9tQixNQUFNLENBQUNUO0FBQ3pCO0FBRUEsSUFBSVUsZUFBZSxXQUFXLEdBQUViLGtCQUFrQkQ7QUFFbEQsSUFBSWUsTUFBTSxXQUFXLEdBQUVyQixPQUFPbUIsTUFBTSxDQUFDO0lBQ2pDRyxXQUFXO0FBQ2Y7QUFFQSxNQUFNQyxNQUFNbkIsS0FBS29CLFdBQVcsQ0FBQztJQUN6QjtRQUFFQyxNQUFNO1FBQU1DLE9BQU87SUFBZTtJQUNwQztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBMkI7SUFDakQ7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQWtCO0lBQ3hDO1FBQUVELE1BQU07UUFBUUMsT0FBTztJQUEwQjtJ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M0QsSUFBSyxJQUFJMkIsSUFBSSxHQUFHQSxJQUFJRCxTQUFTQyxJQUFLO1FBQzlCLElBQUlULENBQUMsQ0FBQ1MsRUFBRSxLQUFLUixDQUFDLENBQUNRLEVBQUUsRUFBRTtZQUNmO1FBQ0o7UUFDQSxPQUFPLENBQUUsQ0FBQ0EsRUFBRSxHQUFHUixDQUFDLENBQUNRLEVBQUUsR0FBSSxDQUFDLElBQUk7SUFDaEM7SUFDQSxPQUFPVCxFQUFFbEIsTUFBTSxHQUFHbUIsRUFBRW5CLE1BQU07QUFDOUI7QUFFQTdHLFdBQVcsR0FBR21CO0FBQ2RuQix3QkFBd0IsR0FBR21JO0FBQzNCbkksMEJBQTBCLEdBQUdvSTtBQUM3QnBJLGlCQUFpQixHQUFHNkg7QUFDcEI3SCxhQUFhLEdBQUdvSDtBQUNoQnBILGNBQWMsR0FBR3FIO0FBQ2pCckgsaUJBQWlCLEdBQUdzSCIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZWhhc2htYXAuZ2l0aHViLmlvLy4vbm9kZV9tb2R1bGVzL3BhcnNlbGV5L2xpYi9wYXJzZWxleS5janM/ZTU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsZWFjID0gcmVxdWlyZSgnbGVhYycpO1xudmFyIHAgPSByZXF1aXJlKCdwZWJlcm1pbnRhJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKHApO1xuXG52YXIgYXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IGxleCA9IGxlYWMuY3JlYXRlTGV4ZXIoW1xuICAgIHsgbmFtZTogJ3dzJywgcmVnZXg6IC9bIFxcdFxcclxcblxcZl0rLyB9LFxuICAgIHsgbmFtZTogJ2lkbicsIHJlZ2V4OiAvW2EtekEtWl8tXVthLXpBLVowLTlfLV0qLyB9LFxuICAgIHsgbmFtZTogJyNpZCcsIHJlZ2V4OiAvI1thLXpBLVowLTlfLV0rLyB9LFxuICAgIHsgbmFtZTogJ3N0cjEnLCByZWdleDogLycoPzpcXFxcWydcXFxcXXxbXlxcbidcXFxcXSkqJy8gfSxcbiAgICB7IG5hbWU6ICdzdHIyJywgcmVnZXg6IC9cIig/OlxcXFxbXCJcXFxcXXxbXlxcblwiXFxcXF0pKlwiLyB9LFxuICAgIHsgbmFtZTogJyonIH0sXG4gICAgeyBuYW1lOiAnLicgfSxcbiAgICB7IG5hbWU6ICcsJyB9LFxuICAgIHsgbmFtZTogJ1snIH0sXG4gICAgeyBuYW1lOiAnXScgfSxcbiAgICB7IG5hbWU6ICc9JyB9LFxuICAgIHsgbmFtZTogJz4nIH0sXG4gICAgeyBuYW1lOiAnfCcgfSxcbiAgICB7IG5hbWU6ICcrJyB9LFxuICAgIHsgbmFtZTogJ34nIH0sXG4gICAgeyBuYW1lOiAnXicgfSxcbiAgICB7IG5hbWU6ICckJyB9LFxuXSk7XG5mdW5jdGlvbiBzdW1TcGVjKFthMCwgYTEsIGEyXSwgW2IwLCBiMSwgYjJdKSB7XG4gICAgcmV0dXJuIFthMCArIGIwLCBhMSArIGIxLCBhMiArIGIyXTtcbn1cbmZ1bmN0aW9uIHN1bUFsbFNwZWMoc3MpIHtcbiAgICByZXR1cm4gc3MucmVkdWNlKHN1bVNwZWMsIFswLCAwLCAwXSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKG5hbWUpIHtcbiAgICByZXR1cm4gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09IG5hbWUgPyB0cnVlIDogdW5kZWZpbmVkKTtcbn1cbmNvbnN0IHdoaXRlc3BhY2VfID0gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICd3cycgPyBudWxsIDogdW5kZWZpbmVkKTtcbmNvbnN0IG9wdGlvbmFsV2hpdGVzcGFjZV8gPSBwX19uYW1lc3BhY2Uub3B0aW9uKHdoaXRlc3BhY2VfLCBudWxsKTtcbmZ1bmN0aW9uIG9wdGlvbmFsbHlTcGFjZWQocGFyc2VyKSB7XG4gICAgcmV0dXJuIHBfX25hbWVzcGFjZS5taWRkbGUob3B0aW9uYWxXaGl0ZXNwYWNlXywgcGFyc2VyLCBvcHRpb25hbFdoaXRlc3BhY2VfKTtcbn1cbmNvbnN0IGlkZW50aWZpZXJfID0gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICdpZG4nID8gdC50ZXh0IDogdW5kZWZpbmVkKTtcbmNvbnN0IGhhc2hJZF8gPSBwX19uYW1lc3BhY2UudG9rZW4oKHQpID0+IHQubmFtZSA9PT0gJyNpZCcgPyB0LnRleHQuc2xpY2UoMSkgOiB1bmRlZmluZWQpO1xuY29uc3Qgc3RyaW5nXyA9IHBfX25hbWVzcGFjZS50b2tlbigodCkgPT4gdC5uYW1lLnN0YXJ0c1dpdGgoJ3N0cicpID8gdC50ZXh0LnNsaWNlKDEsIC0xKSA6IHVuZGVmaW5lZCk7XG5jb25zdCBuYW1lc3BhY2VfID0gcF9fbmFtZXNwYWNlLmxlZnQocF9fbmFtZXNwYWNlLm9wdGlvbihpZGVudGlmaWVyXywgJycpLCBsaXRlcmFsKCd8JykpO1xuY29uc3QgcXVhbGlmaWVkTmFtZV8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3IocF9fbmFtZXNwYWNlLmFiKG5hbWVzcGFjZV8sIGlkZW50aWZpZXJfLCAobnMsIG5hbWUpID0+ICh7IG5hbWU6IG5hbWUsIG5hbWVzcGFjZTogbnMgfSkpLCBwX19uYW1lc3BhY2UubWFwKGlkZW50aWZpZXJfLCAobmFtZSkgPT4gKHsgbmFtZTogbmFtZSwgbmFtZXNwYWNlOiBudWxsIH0pKSk7XG5jb25zdCB1bmlTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3IocF9fbmFtZXNwYWNlLmFiKG5hbWVzcGFjZV8sIGxpdGVyYWwoJyonKSwgKG5zKSA9PiAoeyB0eXBlOiAndW5pdmVyc2FsJywgbmFtZXNwYWNlOiBucywgc3BlY2lmaWNpdHk6IFswLCAwLCAwXSB9KSksIHBfX25hbWVzcGFjZS5tYXAobGl0ZXJhbCgnKicpLCAoKSA9PiAoeyB0eXBlOiAndW5pdmVyc2FsJywgbmFtZXNwYWNlOiBudWxsLCBzcGVjaWZpY2l0eTogWzAsIDAsIDBdIH0pKSk7XG5jb25zdCB0YWdTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubWFwKHF1YWxpZmllZE5hbWVfLCAoeyBuYW1lLCBuYW1lc3BhY2UgfSkgPT4gKHtcbiAgICB0eXBlOiAndGFnJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgIHNwZWNpZmljaXR5OiBbMCwgMCwgMV1cbn0pKTtcbmNvbnN0IGNsYXNzU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJy4nKSwgaWRlbnRpZmllcl8sIChmdWxsc3RvcCwgbmFtZSkgPT4gKHtcbiAgICB0eXBlOiAnY2xhc3MnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAxLCAwXVxufSkpO1xuY29uc3QgaWRTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UubWFwKGhhc2hJZF8sIChuYW1lKSA9PiAoe1xuICAgIHR5cGU6ICdpZCcsXG4gICAgbmFtZTogbmFtZSxcbiAgICBzcGVjaWZpY2l0eTogWzEsIDAsIDBdXG59KSk7XG5jb25zdCBhdHRyTW9kaWZpZXJfID0gcF9fbmFtZXNwYWNlLnRva2VuKCh0KSA9PiB7XG4gICAgaWYgKHQubmFtZSA9PT0gJ2lkbicpIHtcbiAgICAgICAgaWYgKHQudGV4dCA9PT0gJ2knIHx8IHQudGV4dCA9PT0gJ0knKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2knO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LnRleHQgPT09ICdzJyB8fCB0LnRleHQgPT09ICdTJykge1xuICAgICAgICAgICAgcmV0dXJuICdzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufSk7XG5jb25zdCBhdHRyVmFsdWVfID0gcF9fbmFtZXNwYWNlLmVpdGhlck9yKHBfX25hbWVzcGFjZS5hYihzdHJpbmdfLCBwX19uYW1lc3BhY2Uub3B0aW9uKHBfX25hbWVzcGFjZS5yaWdodChvcHRpb25hbFdoaXRlc3BhY2VfLCBhdHRyTW9kaWZpZXJfKSwgbnVsbCksICh2LCBtb2QpID0+ICh7IHZhbHVlOiB2LCBtb2RpZmllcjogbW9kIH0pKSwgcF9fbmFtZXNwYWNlLmFiKGlkZW50aWZpZXJfLCBwX19uYW1lc3BhY2Uub3B0aW9uKHBfX25hbWVzcGFjZS5yaWdodCh3aGl0ZXNwYWNlXywgYXR0ck1vZGlmaWVyXyksIG51bGwpLCAodiwgbW9kKSA9PiAoeyB2YWx1ZTogdiwgbW9kaWZpZXI6IG1vZCB9KSkpO1xuY29uc3QgYXR0ck1hdGNoZXJfID0gcF9fbmFtZXNwYWNlLmNob2ljZShwX19uYW1lc3BhY2UubWFwKGxpdGVyYWwoJz0nKSwgKCkgPT4gJz0nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJ34nKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnfj0nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJ3wnKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnfD0nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJ14nKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnXj0nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJyQnKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnJD0nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJyonKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnKj0nKSk7XG5jb25zdCBhdHRyUHJlc2VuY2VTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuYWJjKGxpdGVyYWwoJ1snKSwgb3B0aW9uYWxseVNwYWNlZChxdWFsaWZpZWROYW1lXyksIGxpdGVyYWwoJ10nKSwgKGxiciwgeyBuYW1lLCBuYW1lc3BhY2UgfSkgPT4gKHtcbiAgICB0eXBlOiAnYXR0clByZXNlbmNlJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgIHNwZWNpZmljaXR5OiBbMCwgMSwgMF1cbn0pKTtcbmNvbnN0IGF0dHJWYWx1ZVNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5taWRkbGUobGl0ZXJhbCgnWycpLCBwX19uYW1lc3BhY2UuYWJjKG9wdGlvbmFsbHlTcGFjZWQocXVhbGlmaWVkTmFtZV8pLCBhdHRyTWF0Y2hlcl8sIG9wdGlvbmFsbHlTcGFjZWQoYXR0clZhbHVlXyksICh7IG5hbWUsIG5hbWVzcGFjZSB9LCBtYXRjaGVyLCB7IHZhbHVlLCBtb2RpZmllciB9KSA9PiAoe1xuICAgIHR5cGU6ICdhdHRyVmFsdWUnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgbWF0Y2hlcjogbWF0Y2hlcixcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbW9kaWZpZXI6IG1vZGlmaWVyLFxuICAgIHNwZWNpZmljaXR5OiBbMCwgMSwgMF1cbn0pKSwgbGl0ZXJhbCgnXScpKTtcbmNvbnN0IGF0dHJTZWxlY3Rvcl8gPSBwX19uYW1lc3BhY2UuZWl0aGVyT3IoYXR0clByZXNlbmNlU2VsZWN0b3JfLCBhdHRyVmFsdWVTZWxlY3Rvcl8pO1xuY29uc3QgdHlwZVNlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcih1bmlTZWxlY3Rvcl8sIHRhZ1NlbGVjdG9yXyk7XG5jb25zdCBzdWJjbGFzc1NlbGVjdG9yXyA9IHBfX25hbWVzcGFjZS5jaG9pY2UoaWRTZWxlY3Rvcl8sIGNsYXNzU2VsZWN0b3JfLCBhdHRyU2VsZWN0b3JfKTtcbmNvbnN0IGNvbXBvdW5kU2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLm1hcChwX19uYW1lc3BhY2UuZWl0aGVyT3IocF9fbmFtZXNwYWNlLmZsYXR0ZW4odHlwZVNlbGVjdG9yXywgcF9fbmFtZXNwYWNlLm1hbnkoc3ViY2xhc3NTZWxlY3Rvcl8pKSwgcF9fbmFtZXNwYWNlLm1hbnkxKHN1YmNsYXNzU2VsZWN0b3JfKSksIChzcykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb21wb3VuZCcsXG4gICAgICAgIGxpc3Q6IHNzLFxuICAgICAgICBzcGVjaWZpY2l0eTogc3VtQWxsU3BlYyhzcy5tYXAocyA9PiBzLnNwZWNpZmljaXR5KSlcbiAgICB9O1xufSk7XG5jb25zdCBjb21iaW5hdG9yXyA9IHBfX25hbWVzcGFjZS5jaG9pY2UocF9fbmFtZXNwYWNlLm1hcChsaXRlcmFsKCc+JyksICgpID0+ICc+JyksIHBfX25hbWVzcGFjZS5tYXAobGl0ZXJhbCgnKycpLCAoKSA9PiAnKycpLCBwX19uYW1lc3BhY2UubWFwKGxpdGVyYWwoJ34nKSwgKCkgPT4gJ34nKSwgcF9fbmFtZXNwYWNlLmFiKGxpdGVyYWwoJ3wnKSwgbGl0ZXJhbCgnfCcpLCAoKSA9PiAnfHwnKSk7XG5jb25zdCBjb21iaW5hdG9yU2VwYXJhdG9yXyA9IHBfX25hbWVzcGFjZS5laXRoZXJPcihvcHRpb25hbGx5U3BhY2VkKGNvbWJpbmF0b3JfKSwgcF9fbmFtZXNwYWNlLm1hcCh3aGl0ZXNwYWNlXywgKCkgPT4gJyAnKSk7XG5jb25zdCBjb21wbGV4U2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmxlZnRBc3NvYzIoY29tcG91bmRTZWxlY3Rvcl8sIHBfX25hbWVzcGFjZS5tYXAoY29tYmluYXRvclNlcGFyYXRvcl8sIChjKSA9PiAobGVmdCwgcmlnaHQpID0+ICh7XG4gICAgdHlwZTogJ2NvbXBvdW5kJyxcbiAgICBsaXN0OiBbLi4ucmlnaHQubGlzdCwgeyB0eXBlOiAnY29tYmluYXRvcicsIGNvbWJpbmF0b3I6IGMsIGxlZnQ6IGxlZnQsIHNwZWNpZmljaXR5OiBsZWZ0LnNwZWNpZmljaXR5IH1dLFxuICAgIHNwZWNpZmljaXR5OiBzdW1TcGVjKGxlZnQuc3BlY2lmaWNpdHksIHJpZ2h0LnNwZWNpZmljaXR5KVxufSkpLCBjb21wb3VuZFNlbGVjdG9yXyk7XG5jb25zdCBsaXN0U2VsZWN0b3JfID0gcF9fbmFtZXNwYWNlLmxlZnRBc3NvYzIocF9fbmFtZXNwYWNlLm1hcChjb21wbGV4U2VsZWN0b3JfLCAocykgPT4gKHsgdHlwZTogJ2xpc3QnLCBsaXN0OiBbc10gfSkpLCBwX19uYW1lc3BhY2UubWFwKG9wdGlvbmFsbHlTcGFjZWQobGl0ZXJhbCgnLCcpKSwgKCkgPT4gKGFjYywgbmV4dCkgPT4gKHsgdHlwZTogJ2xpc3QnLCBsaXN0OiBbLi4uYWNjLmxpc3QsIG5leHRdIH0pKSwgY29tcGxleFNlbGVjdG9yXyk7XG5mdW5jdGlvbiBwYXJzZV8ocGFyc2VyLCBzdHIpIHtcbiAgICBjb25zdCBsZXhlclJlc3VsdCA9IGxleChzdHIpO1xuICAgIGlmICghbGV4ZXJSZXN1bHQuY29tcGxldGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5wdXQgXCIke3N0cn1cIiB3YXMgb25seSBwYXJ0aWFsbHkgdG9rZW5pemVkLCBzdG9wcGVkIGF0IG9mZnNldCAke2xleGVyUmVzdWx0Lm9mZnNldH0hXFxuYCArXG4gICAgICAgICAgICBwcmV0dHlQcmludFBvc2l0aW9uKHN0ciwgbGV4ZXJSZXN1bHQub2Zmc2V0KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbmFsbHlTcGFjZWQocGFyc2VyKSh7IHRva2VuczogbGV4ZXJSZXN1bHQudG9rZW5zLCBvcHRpb25zOiB1bmRlZmluZWQgfSwgMCk7XG4gICAgaWYgKCFyZXN1bHQubWF0Y2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoIGZvciBcIiR7c3RyfVwiIGlucHV0IWApO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvc2l0aW9uIDwgbGV4ZXJSZXN1bHQudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGxleGVyUmVzdWx0LnRva2Vuc1tyZXN1bHQucG9zaXRpb25dO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbnB1dCBcIiR7c3RyfVwiIHdhcyBvbmx5IHBhcnRpYWxseSBwYXJzZWQsIHN0b3BwZWQgYXQgb2Zmc2V0ICR7dG9rZW4ub2Zmc2V0fSFcXG5gICtcbiAgICAgICAgICAgIHByZXR0eVByaW50UG9zaXRpb24oc3RyLCB0b2tlbi5vZmZzZXQsIHRva2VuLmxlbikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gcHJldHR5UHJpbnRQb3NpdGlvbihzdHIsIG9mZnNldCwgbGVuID0gMSkge1xuICAgIHJldHVybiBgJHtzdHIucmVwbGFjZSgvKFxcdCl8KFxccil8KFxcbikvZywgKG0sIHQsIHIpID0+IHQgPyAnXFx1MjQwOScgOiByID8gJ1xcdTI0MGQnIDogJ1xcdTI0MGEnKX1cXG4keycnLnBhZEVuZChvZmZzZXQpfSR7J14nLnJlcGVhdChsZW4pfWA7XG59XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VfKGxpc3RTZWxlY3Rvcl8sIHN0cik7XG59XG5mdW5jdGlvbiBwYXJzZTEoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlXyhjb21wbGV4U2VsZWN0b3JfLCBzdHIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIG5vdCBhbiBBU1Qgbm9kZS4nKTtcbiAgICB9XG4gICAgc3dpdGNoIChzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuaXZlcnNhbCc6XG4gICAgICAgICAgICByZXR1cm4gX3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSkgKyAnKic7XG4gICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICByZXR1cm4gX3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSkgKyBzZWxlY3Rvci5uYW1lO1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICByZXR1cm4gJy4nICsgc2VsZWN0b3IubmFtZTtcbiAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgcmV0dXJuICcjJyArIHNlbGVjdG9yLm5hbWU7XG4gICAgICAgIGNhc2UgJ2F0dHJQcmVzZW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gYFske19zZXJOcyhzZWxlY3Rvci5uYW1lc3BhY2UpfSR7c2VsZWN0b3IubmFtZX1dYDtcbiAgICAgICAgY2FzZSAnYXR0clZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBgWyR7X3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSl9JHtzZWxlY3Rvci5uYW1lfSR7c2VsZWN0b3IubWF0Y2hlcn0ke19zZXJTdHIoc2VsZWN0b3IudmFsdWUpfSR7KHNlbGVjdG9yLm1vZGlmaWVyID8gc2VsZWN0b3IubW9kaWZpZXIgOiAnJyl9XWA7XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShzZWxlY3Rvci5sZWZ0KSArIHNlbGVjdG9yLmNvbWJpbmF0b3I7XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5saXN0LnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbWJpbmF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUobm9kZSkgKyBhY2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgc2VyaWFsaXplKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IubGlzdC5tYXAoc2VyaWFsaXplKS5qb2luKCcsJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3Nlck5zKG5zKSB7XG4gICAgcmV0dXJuIChucyB8fCBucyA9PT0gJycpXG4gICAgICAgID8gbnMgKyAnfCdcbiAgICAgICAgOiAnJztcbn1cbmZ1bmN0aW9uIF9zZXJTdHIoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKCdcIicpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYFwiJHtzdHJ9XCJgO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHIuaW5kZXhPZihcIidcIikgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBgJyR7c3RyfSdgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7c3RyLnJlcGxhY2UoJ1wiJywgJ1xcXFxcIicpfVwiYDtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemUoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIG5vdCBhbiBBU1Qgbm9kZS4nKTtcbiAgICB9XG4gICAgc3dpdGNoIChzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzoge1xuICAgICAgICAgICAgc2VsZWN0b3IubGlzdC5mb3JFYWNoKG5vcm1hbGl6ZSk7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LnNvcnQoKGEsIGIpID0+IF9jb21wYXJlQXJyYXlzKF9nZXRTZWxlY3RvclByaW9yaXR5KGEpLCBfZ2V0U2VsZWN0b3JQcmlvcml0eShiKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29tYmluYXRvcic6IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShzZWxlY3Rvci5sZWZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LmZvckVhY2gobm9ybWFsaXplKTtcbiAgICAgICAgICAgIHNlbGVjdG9yLmxpc3Quc29ydCgoYSwgYikgPT4gKHNlcmlhbGl6ZShhKSA8IHNlcmlhbGl6ZShiKSkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFNlbGVjdG9yUHJpb3JpdHkoc2VsZWN0b3IpIHtcbiAgICBzd2l0Y2ggKHNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5pdmVyc2FsJzpcbiAgICAgICAgICAgIHJldHVybiBbMV07XG4gICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICByZXR1cm4gWzFdO1xuICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICByZXR1cm4gWzMsIHNlbGVjdG9yLm5hbWVdO1xuICAgICAgICBjYXNlICdhdHRyUHJlc2VuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIFs0LCBzZXJpYWxpemUoc2VsZWN0b3IpXTtcbiAgICAgICAgY2FzZSAnYXR0clZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBbNSwgc2VyaWFsaXplKHNlbGVjdG9yKV07XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgcmV0dXJuIFsxNSwgc2VyaWFsaXplKHNlbGVjdG9yKV07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVNlbGVjdG9ycyhhLCBiKSB7XG4gICAgcmV0dXJuIF9jb21wYXJlQXJyYXlzKGEuc3BlY2lmaWNpdHksIGIuc3BlY2lmaWNpdHkpO1xufVxuZnVuY3Rpb24gY29tcGFyZVNwZWNpZmljaXR5KGEsIGIpIHtcbiAgICByZXR1cm4gX2NvbXBhcmVBcnJheXMoYSwgYik7XG59XG5mdW5jdGlvbiBfY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnRzIG11c3QgYmUgYXJyYXlzLicpO1xuICAgIH1cbiAgICBjb25zdCBzaG9ydGVyID0gKGEubGVuZ3RoIDwgYi5sZW5ndGgpID8gYS5sZW5ndGggOiBiLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXI7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhW2ldIDwgYltpXSkgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG5leHBvcnRzLkFzdCA9IGFzdDtcbmV4cG9ydHMuY29tcGFyZVNlbGVjdG9ycyA9IGNvbXBhcmVTZWxlY3RvcnM7XG5leHBvcnRzLmNvbXBhcmVTcGVjaWZpY2l0eSA9IGNvbXBhcmVTcGVjaWZpY2l0eTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZTEgPSBwYXJzZTE7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImxlYWMiLCJyZXF1aXJlIiwicCIsIl9pbnRlcm9wTmFtZXNwYWNlIiwiZSIsIl9fZXNNb2R1bGUiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJmcmVlemUiLCJwX19uYW1lc3BhY2UiLCJhc3QiLCJfX3Byb3RvX18iLCJsZXgiLCJjcmVhdGVMZXhlciIsIm5hbWUiLCJyZWdleCIsInN1bVNwZWMiLCJhMCIsImExIiwiYTIiLCJiMCIsImIxIiwiYjIiLCJzdW1BbGxTcGVjIiwic3MiLCJyZWR1Y2UiLCJsaXRlcmFsIiwidG9rZW4iLCJ0IiwidW5kZWZpbmVkIiwid2hpdGVzcGFjZV8iLCJvcHRpb25hbFdoaXRlc3BhY2VfIiwib3B0aW9uIiwib3B0aW9uYWxseVNwYWNlZCIsInBhcnNlciIsIm1pZGRsZSIsImlkZW50aWZpZXJfIiwidGV4dCIsImhhc2hJZF8iLCJzbGljZSIsInN0cmluZ18iLCJzdGFydHNXaXRoIiwibmFtZXNwYWNlXyIsImxlZnQiLCJxdWFsaWZpZWROYW1lXyIsImVpdGhlck9yIiwiYWIiLCJucyIsIm5hbWVzcGFjZSIsIm1hcCIsInVuaVNlbGVjdG9yXyIsInR5cGUiLCJzcGVjaWZpY2l0eSIsInRhZ1NlbGVjdG9yXyIsImNsYXNzU2VsZWN0b3JfIiwiZnVsbHN0b3AiLCJpZFNlbGVjdG9yXyIsImF0dHJNb2RpZmllcl8iLCJhdHRyVmFsdWVfIiwicmlnaHQiLCJ2IiwibW9kIiwibW9kaWZpZXIiLCJhdHRyTWF0Y2hlcl8iLCJjaG9pY2UiLCJhdHRyUHJlc2VuY2VTZWxlY3Rvcl8iLCJhYmMiLCJsYnIiLCJhdHRyVmFsdWVTZWxlY3Rvcl8iLCJtYXRjaGVyIiwiYXR0clNlbGVjdG9yXyIsInR5cGVTZWxlY3Rvcl8iLCJzdWJjbGFzc1NlbGVjdG9yXyIsImNvbXBvdW5kU2VsZWN0b3JfIiwiZmxhdHRlbiIsIm1hbnkiLCJtYW55MSIsImxpc3QiLCJzIiwiY29tYmluYXRvcl8iLCJjb21iaW5hdG9yU2VwYXJhdG9yXyIsImNvbXBsZXhTZWxlY3Rvcl8iLCJsZWZ0QXNzb2MyIiwiYyIsImNvbWJpbmF0b3IiLCJsaXN0U2VsZWN0b3JfIiwiYWNjIiwibmV4dCIsInBhcnNlXyIsInN0ciIsImxleGVyUmVzdWx0IiwiY29tcGxldGUiLCJFcnJvciIsIm9mZnNldCIsInByZXR0eVByaW50UG9zaXRpb24iLCJyZXN1bHQiLCJ0b2tlbnMiLCJvcHRpb25zIiwibWF0Y2hlZCIsInBvc2l0aW9uIiwibGVuZ3RoIiwibGVuIiwicmVwbGFjZSIsIm0iLCJyIiwicGFkRW5kIiwicmVwZWF0IiwicGFyc2UiLCJwYXJzZTEiLCJzZXJpYWxpemUiLCJzZWxlY3RvciIsIl9zZXJOcyIsIl9zZXJTdHIiLCJub2RlIiwiam9pbiIsImluZGV4T2YiLCJub3JtYWxpemUiLCJzb3J0IiwiYSIsImIiLCJfY29tcGFyZUFycmF5cyIsIl9nZXRTZWxlY3RvclByaW9yaXR5IiwiY29tcGFyZVNlbGVjdG9ycyIsImNvbXBhcmVTcGVjaWZpY2l0eSIsIkFycmF5IiwiaXNBcnJheSIsInNob3J0ZXIiLCJpIiwiQXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/parseley/lib/parseley.cjs\n");

/***/ })

};
;